{"pages":[{"title":"关于","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"bookmark","text":"","link":"/bookmark/index.html"}],"posts":[{"title":"Java时间格式化SimpleDateFormat","text":"SimpleDateFormat函数语法12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.text.*;import java.util.Date;/** SimpleDateFormat函数语法： G 年代标志符 y 年 M 月 d 日 h 时 在上午或下午 (1~12) H 时 在一天中 (0~23) m 分 s 秒 S 毫秒 E 星期 D 一年中的第几天 F 一月中第几个星期几 w 一年中第几个星期 W 一月中第几个星期 a 上午 / 下午 标记符 k 时 在一天中 (1~24) K 时 在上午或下午 (0~11) z 时区 */public class FormatDateTime { public static void main(String[] args) { SimpleDateFormat myFmt=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); SimpleDateFormat myFmt1=new SimpleDateFormat(&quot;yy/MM/dd HH:mm&quot;); SimpleDateFormat myFmt2=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//等价于now.toLocaleString() SimpleDateFormat myFmt3=new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;); SimpleDateFormat myFmt4=new SimpleDateFormat( &quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;); Date now=new Date(); System.out.println(myFmt.format(now)); System.out.println(myFmt1.format(now)); System.out.println(myFmt2.format(now)); System.out.println(myFmt3.format(now)); System.out.println(myFmt4.format(now)); System.out.println(now.toGMTString()); System.out.println(now.toLocaleString()); System.out.println(now.toString()); } } 效果123456782004年12月16日 17时24分27秒04/12/16 17:242004-12-16 17:24:272004年12月16日 17时24分27秒 星期四一年中的第 351 天 一年中第51个星期 一月中第3个星期 在一天中17时 CST时区16 Dec 2004 09:24:27 GMT2004-12-16 17:24:27Thu Dec 16 17:24:27 CST 2004","link":"/2020/09/10/Java/Java%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96SimpleDateFormat/"},{"title":"安装Docker","text":"参考 Centos中安装Docker 下载源1wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装1yum install -y docker-ce 启动1systemctl start docker 开机自启1systemctl enable docker","link":"/2020/09/14/Docker/%E5%AE%89%E8%A3%85Docker/"},{"title":"安装DockerUI","text":"参考 Docker 三种UI管理平台 下载镜像1docker pull uifd/ui-for-docker 启动123docker run -it -d --name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-dockerhttp://192.168.11.199:9000 12守护进程重启 sudo systemctl daemon-reload重启docker服务 systemctl restart docker","link":"/2020/09/14/Docker/%E5%AE%89%E8%A3%85DockerUI/"},{"title":"CentOS8配置固定IP","text":"参考 (CentOS 修改固定IP地址)[https://www.cnblogs.com/weschen/p/11230322.html] 查看网络设置1ip addr 或者 ifconfig -a 修改网络配置1vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改前123456789101112131415TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;dhcp&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9039d69f-5e85-4948-b644-269a4fd80afb&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot; 修改后123456789101112131415161718192021TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot;DEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;9039d69f-5e85-4948-b644-269a4fd80afb&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;# 设置IP地址PREFIX=24IPADDR=192.168.1.7GATEWAY=192.168.1.1NETMASK=255.255.255.0DNS1=192.168.1.1 重启网卡 方法：nmcli c reload +网卡名 1nmcli c reload ens33","link":"/2020/09/12/CentOS/CentOS8%E9%85%8D%E7%BD%AE%E5%9B%BA%E5%AE%9AIP/"},{"title":"Docker开启远程访问端口2376","text":"参考 centos7 docker开启认证的远程端口2376配置教程 生成证书参照 centos7 docker配置TLS认证的远程端口的证书生成教程（shell脚本一键生成） 编辑docker文件1vi /usr/lib/systemd/system/docker.service","link":"/2020/09/14/Docker/Docker%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A32376/"},{"title":"Kubernetes学习笔记一","text":"参照 (二进制方式安装)[https://www.yuque.com/duduniao/k8s/tr3hch] 修改网络配置（NAT模式）1vi /etc/sysconfig/network-scripts/ifcfg-ens33 1234567891011121314151617181920TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=aa8a9f62-a1c9-4863-8819-2aa82f85d043DEVICE=ens33ONBOOT=yesIPADDR=192.168.73.11NETMASK=255.255.255.0GATEWAY=192.168.73.2DNS1=192.168.73.2DNS2=114.114.114.114 修改机器名1hostnamectl set-hostname k8s-master01 关闭SELinux查看SELinux状态1getenforce 关闭SELinux123vim /etc/sysconfig/selinuxSELINUX=enforcing 替换为SELINUX=disabled 查看内核版本(Docker要求3.8以上)123uname -aLinux hdss7-11.host.com 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 关闭防火墙1systemctl stop firewalld 安装epel-release1sudo yum install -y epel-release 安装必要工具1yum install -y wget net-tools telnet tree nmap sysstat lrzsz dos2unix bind-utils vim less DNS服务器初始化hsdd-11.host.com 安装bind9123yum install -y bindrpm -qa bind 修改配置文件123456789101112131415161718192021222324252627282930vi /etc/named.confoptions { listen-on port 53 { 192.168.73.11; }; directory &quot;/var/named&quot;; dump-file &quot;/var/named/data/cache_dump.db&quot;; statistics-file &quot;/var/named/data/named_stats.txt&quot;; memstatistics-file &quot;/var/named/data/named_mem_stats.txt&quot;; recursing-file &quot;/var/named/data/named.recursing&quot;; secroots-file &quot;/var/named/data/named.secroots&quot;; allow-query { any; }; forwarders { 192.168.73.2; }; /* - If you are building an AUTHORITATIVE DNS server, do NOT enable recursion. - If you are building a RECURSIVE (caching) DNS server, you need to enable recursion. - If your recursive DNS server has a public IP address, you MUST enable access control to limit queries to your legitimate users. Failing to do so will cause your server to become part of large scale DNS amplification attacks. Implementing BCP38 within your network would greatly reduce such attack surface */ recursion yes; dnssec-enable no; dnssec-validation no;#检查配置文件named-checkconf 配置区域文件1234567891011121314vim /etc/named.rfc1912.zones# 增加两个zone配置，od.com为业务域，host.com.zone为主机域zone &quot;host.com&quot; IN { type master; file &quot;host.com.zone&quot;; allow-update { 192.168.73.11; };};zone &quot;od.com&quot; IN { type master; file &quot;od.com.zone&quot;; allow-update { 192.168.73.11; };}; 配置主机域文件1234567891011121314151617181920vim /var/named/host.com.zone# 增加内容（注意修改时间）$ORIGIN host.com.$TTL 600 ; 10 minutes@ IN SOA dns.host.com. dnsadmin.host.com. ( 2020091301 ; serial 10800 ; refresh (3 hours) 900 ; retry (15 minutes) 604800 ; expire (1 week) 86400 ; minimum (1 day) ) NS dns.host.com.$TTL 60 ; 1 minutedns A 192.168.73.11HDSS7-11 A 192.168.73.11HDSS7-12 A 192.168.73.12HDSS7-21 A 192.168.73.21HDSS7-22 A 192.168.73.22HDSS7-200 A 192.168.73.200 配置业务域文件123456789101112131415vim /var/named/od.com.zone# 增加内容$ORIGIN od.com.$TTL 600 ; 10 minutes@ IN SOA dns.od.com. dnsadmin.od.com. ( 2020091301 ; serial 10800 ; refresh (3 hours) 900 ; retry (15 minutes) 604800 ; expire (1 week) 86400 ; minimum (1 day) ) NS dns.od.com.$TTL 60 ; 1 minutedns A 192.168.73.11 启动bind服务，并测试1234named-checkconf # 检查配置文件systemctl start named ; systemctl enable namednetstat -luntp|grep 53host HDSS7-200 192.168.73.11 ; dig -t A hdss7-21.host.com @192.168.73.11 +short 修改所有主机的dns服务器地址12345sed -i '/DNS1/s/192.168.73.2/192.168.73.11/' /etc/sysconfig/network-scripts/ifcfg-ens33systemctl restart networkcat /etc/resolv.conf 修改VMnet8本次实验环境使用的是虚拟机，因此也要对windows宿主机NAT网卡DNS进行修改 1192.168.73.11 根证书准备在 hdss7-200 下载工具1234[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssl-json[root@hdss7-200 ~]# wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -O /usr/local/bin/cfssl-certinfo[root@hdss7-200 ~]# chmod u+x /usr/local/bin/cfssl* 创建生成CA证书签名请求(csr)的json配置文件1234567891011121314151617181920212223242526272829303132333435363738# 根证书配置：# CN 一般写域名，浏览器会校验# names 为地区和公司信息# expiry 为过期时间[root@hdss7-200 certs]# vim /opt/certs/ca-csr.json{ &quot;CN&quot;: &quot;OldboyEdu&quot;, &quot;hosts&quot;: [ ], &quot;key&quot;: { &quot;algo&quot;: &quot;rsa&quot;, &quot;size&quot;: 2048 }, &quot;names&quot;: [ { &quot;C&quot;: &quot;CN&quot;, &quot;ST&quot;: &quot;beijing&quot;, &quot;L&quot;: &quot;beijing&quot;, &quot;O&quot;: &quot;od&quot;, &quot;OU&quot;: &quot;ops&quot; } ], &quot;ca&quot;: { &quot;expiry&quot;: &quot;175200h&quot; }}[root@hdss7-200 certs]# cfssl gencert -initca ca-csr.json | cfssljson -bare ca2020/01/05 10:42:07 [INFO] generating a new CA key and certificate from CSR2020/01/05 10:42:07 [INFO] generate received request2020/01/05 10:42:07 [INFO] received CSR2020/01/05 10:42:07 [INFO] generating key: rsa-20482020/01/05 10:42:08 [INFO] encoded CSR2020/01/05 10:42:08 [INFO] signed certificate with serial number 451005524427475354617025362003367427117323539780[root@hdss7-200 certs]# ls -l ca*-rw-r--r-- 1 root root 993 Jan 5 10:42 ca.csr-rw-r--r-- 1 root root 328 Jan 5 10:39 ca-csr.json-rw------- 1 root root 1675 Jan 5 10:42 ca-key.pem-rw-r--r-- 1 root root 1346 Jan 5 10:42 ca.pem Docker环境准备需要安装docker的机器：hdss7-21 hdss7-22 hdss7-200 1234567891011121314151617[root@hdss7-21 ~]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo[root@hdss7-21 ~]# yum install -y docker-ce[root@hdss7-21 ~]# mkdir /etc/docker/# 不安全的registry中增加了harbor地址# 各个机器上bip网段不一致，bip中间两段与宿主机最后两段相同，目的是方便定位问题 [root@hdss7-21 ~]# vim /etc/docker/daemon.json{ &quot;graph&quot;: &quot;/data/docker&quot;, &quot;storage-driver&quot;: &quot;overlay2&quot;, &quot;insecure-registries&quot;: [&quot;registry.access.redhat.com&quot;,&quot;quay.io&quot;,&quot;harbor.od.com&quot;], &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;], &quot;bip&quot;: &quot;172.7.21.1/24&quot;, &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;], &quot;live-restore&quot;: true}[root@hdss7-21 ~]# mkdir -p /data/docker[root@hdss7-21 ~]# systemctl start docker ; systemctl enable docker harbor安装参考地址：https://www.yuque.com/duduniao/trp3ic/ohrxds#9Zpxx官方地址：https://goharbor.io/下载地址：https://github.com/goharbor/harbor/releases hdss7-200 安装harbor1234567891011121314151617181920212223242526272829303132333435# 目录说明：# /opt/src : 源码、文件下载目录# /opt/release : 各个版本软件存放位置# /opt/apps : 各个软件当前版本的软链接[root@hdss7-200 ~]# cd /opt/src[root@hdss7-200 src]# wget https://github.com/goharbor/harbor/releases/download/v1.9.4/harbor-offline-installer-v1.9.4.tgz[root@hdss7-200 src]# mv harbor /opt/release/harbor-v1.9.4[root@hdss7-200 src]# ln -s /opt/release/harbor-v1.9.4 /opt/apps/harbor[root@hdss7-200 src]# ll /opt/apps/total 0lrwxrwxrwx 1 root root 26 Jan 5 11:13 harbor -&gt; /opt/release/harbor-v1.9.4# 实验环境仅修改以下配置项，生产环境还得修改密码[root@hdss7-200 src]# vim /opt/apps/harbor/harbor.ymlhostname: harbor.od.comhttp: port: 180data_volume: /data/harborlocation: /data/harbor/logs[root@hdss7-200 src]# yum install -y docker-compose[root@hdss7-200 src]# cd /opt/apps/harbor/[root@hdss7-200 harbor]# ./install.sh ......✔ ----Harbor has been installed and started successfully.----[root@hdss7-200 harbor]# docker-compose ps Name Command State Ports --------------------------------------------------------------------------------------harbor-core /harbor/harbor_core Up harbor-db /docker-entrypoint.sh Up 5432/tcp harbor-jobservice /harbor/harbor_jobservice ... Up harbor-log /bin/sh -c /usr/local/bin/ ... Up 127.0.0.1:1514-&gt;10514/tcpharbor-portal nginx -g daemon off; Up 8080/tcp nginx nginx -g daemon off; Up 0.0.0.0:180-&gt;8080/tcp redis redis-server /etc/redis.conf Up 6379/tcp registry /entrypoint.sh /etc/regist ... Up 5000/tcp registryctl /harbor/start.sh Up","link":"/2020/09/13/Kubernetes/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"title":"Maven父工程","text":"pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.grizzly&lt;/groupId&gt; &lt;artifactId&gt;base&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;base-redis&lt;/module&gt; &lt;module&gt;base-mybatis-plus&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--统一管理jar包和版本--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt; &lt;mysql.version&gt;8.0.18&lt;/mysql.version&gt; &lt;druid.verison&gt;1.1.16&lt;/druid.verison&gt; &lt;mybatis.spring.boot.verison&gt;1.3.0&lt;/mybatis.spring.boot.verison&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--spring boot 2.3.3--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud Hoxton.SR8--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR8&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring cloud alibaba 2.2.1.RELEASE--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySql --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${druid.verison}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-springboot整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${mybatis.spring.boot.verison}&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;${lombok.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;${log4j.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;addResources&gt;true&lt;/addResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","link":"/2020/09/12/Maven/Maven%E7%88%B6%E5%B7%A5%E7%A8%8B/"},{"title":"MyBatis-Plus学习笔记一","text":"官网 MyBatis-Plus 引入Maven坐标12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 开启扫描12345678910111213package com.grizzly.base;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.grizzly.base.mapper&quot;)public class MyBatisPlusApplication { public static void main(String[] args) { SpringApplication.run(MyBatisPlusApplication.class, args); }} 实体类建表12345678910DROP TABLE IF EXISTS user;CREATE TABLE user( id BIGINT(20) NOT NULL COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id)); 写入数据12345678DELETE FROM user;INSERT INTO user (id, name, age, email) VALUES(1, 'Jone', 18, 'test1@baomidou.com'),(2, 'Jack', 20, 'test2@baomidou.com'),(3, 'Tom', 28, 'test3@baomidou.com'),(4, 'Sandy', 21, 'test4@baomidou.com'),(5, 'Billie', 24, 'test5@baomidou.com'); 编写实体类1234567891011package com.grizzly.base.entity;import lombok.Data;@Datapublic class User { private Long id; private String name; private Integer age; private String email;} 编写接口12345678package com.grizzly.base.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.grizzly.base.entity.User;public interface UserMapper extends BaseMapper&lt;User&gt; {} 调用1234567891011121314151617181920212223242526package com.grizzly.base;import com.baomidou.mybatisplus.extension.api.Assert;import com.grizzly.base.entity.User;import com.grizzly.base.mapper.UserMapper;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.util.List;@SpringBootTestpublic class MyBatisPlusApplicationTest { @Autowired private UserMapper userMapper; @Test public void testSelect() { System.out.println((&quot;----- selectAll method test ------&quot;)); List&lt;User&gt; userList = userMapper.selectList(null);// Assert.assertEquals(5, userList.size()); userList.forEach(System.out::println); }}","link":"/2020/09/12/MyBatis-Plus/MyBatis-Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"title":"MySQL DATE_FORMAT() 函数","text":"参考 MySQL DATE_FORMAT() 函数","link":"/2020/09/12/MySQL/MySQL-DATE-FORMAT-%E5%87%BD%E6%95%B0/"},{"title":"Redis序列化","text":"参考 redisTemplate和stringRedisTemplate对比、redisTemplate几种序列化方式比较 配置类12345678910111213141516171819@Configurationpublic class RedisConfig { @Bean(name = &quot;redisTemplate&quot;) public RedisTemplate&lt;String, Object&gt; getRedisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;(); redisTemplate.setConnectionFactory(factory); redisTemplate.setKeySerializer(new StringRedisSerializer()); // key的序列化类型 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);// objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); // value的序列化类型 return redisTemplate; }} enableDefaultTyping方法过时参考 RedisTemplate配置的jackson.ObjectMapper里的一个enableDefaultTyping方法过期解决 1objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); 替换为 1objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance,ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.WRAPPER_ARRAY);","link":"/2020/09/12/Redis/Redis%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Redis学习笔记一","text":"引入Maven坐标123456&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 配置12345678910spring: redis: # Redis数据库索引（默认为0） database: 1 # Redis服务器地址 host: localhost # Redis服务器连接端口 port: 6379 # Redis服务器连接密码（默认为空） password: 自动注入12@Autowiredprivate RedisTemplate redisTemplate; 操作1234567//增、改redisTemplate.opsForValue().set(&quot;user&quot;,&quot;wxf&quot;);//查//获取时根据存入的类型做转换redisTemplate.opsForValue().get(&quot;user&quot;);//删redisTemplate.delete(&quot;user&quot;);","link":"/2020/09/12/Redis/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"},{"title":"Spring AOP","text":"引入Maven坐标1234&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt; 编写配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.yearcon.joowing.aop;import io.swagger.annotations.ApiOperation;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import java.util.Enumeration;@Component@Aspect@Slf4jpublic class LoggerAdvice { @Before(&quot;within(cn.yearcon.joowing.controller..*) &amp;&amp; @annotation(apiOperation)&quot;) public void addBeforeLogger(JoinPoint joinPoint, ApiOperation apiOperation) { log.info(&quot;==&gt;执行【&quot; + apiOperation.value() + &quot;】开始&quot;); log.info(joinPoint.getSignature().toString()); log.info(parseParames(joinPoint.getArgs())); } @AfterReturning(returning = &quot;rvt&quot;, value = &quot;within(cn.yearcon.joowing.controller..*) &amp;&amp; @annotation(apiOperation)&quot;) public void addAfterReturningLogger(JoinPoint joinPoint, Object rvt, ApiOperation apiOperation) { log.info(&quot;返回结果:{}&quot;, rvt); log.info(&quot;执行 【&quot; + apiOperation.value() + &quot;】 结束&quot;); } @AfterThrowing(pointcut = &quot;within(cn.yearcon.joowing.controller..*) &amp;&amp; @annotation(apiOperation)&quot;, throwing = &quot;ex&quot;) public void addAfterThrowingLogger(JoinPoint joinPoint, ApiOperation apiOperation, Exception ex) { log.error(&quot; ****************执行 【&quot; + apiOperation.value() + &quot;】 异常 ****************&quot;, ex); } private String parseParames(Object[] parames) { if (null == parames || parames.length &lt;= 0) { return &quot;&quot;; } StringBuffer param = new StringBuffer(&quot;传入参数 # 个:【 &quot;); int i = 0; for (Object obj : parames) { if (obj instanceof HttpServletRequest) { HttpServletRequest request = (HttpServletRequest) obj; Enumeration&lt;String&gt; params = request.getParameterNames(); while (params.hasMoreElements()) { String paraName = params.nextElement(); log.info(&quot;参数:{}={}&quot;, paraName, request.getParameter(paraName)); } } i++; if (i == 1) { param.append(obj); continue; } param.append(&quot;,&quot;).append(obj); } return param.append(&quot; 】&quot;).toString().replace(&quot;#&quot;, String.valueOf(i)); }}","link":"/2020/09/12/Spring/Spring-AOP/"},{"title":"Spring Boot Cache整合与使用","text":"参考 史上最全的Spring Boot Cache使用与整合","link":"/2020/09/12/Spring%20Boot/Spring-Boot-Cache%E6%95%B4%E5%90%88%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"Spring Boot数据源配置","text":"Spring Boot 2.3.3版本默认采用Hikari数据库连接池 单数据源配置application.yml1234567891011121314151617181920212223242526272829server: port: 80# 数据库配置spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.80.245:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2b8 username: root password: aa123456 # Hikari 连接池配置 hikari: # 最小空闲连接数量 minimum-idle: 5 # 空闲连接存活最大时间，默认600000（10分钟） idle-timeout: 180000 # 连接池最大连接数，默认是10 maximum-pool-size: 10 # 此属性控制从池返回的连接的默认自动提交行为,默认值：true auto-commit: true # 连接池名称 pool-name: MyHikariCP # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认1800000即30分钟 max-lifetime: 1800000 # 数据库连接超时时间,默认30秒，即30000 connection-timeout: 30000 connection-test-query: SELECT 1mybatis: mapper-locations: classpath:mapper/*.xml","link":"/2020/09/12/Spring%20Boot/Spring-Boot%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"},{"title":"SpringBoot上传镜像到远程仓库","text":"参考 Docker开启Remote API 访问 2375端口 开启服务器3375端口1234vim /usr/lib/systemd/system/docker.service#修改为ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock 重启Docker12systemctl daemon-reloadsystemctl restart docker 引入Maven插件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;io.fabric8&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.30.0&lt;/version&gt; &lt;configuration&gt; &lt;dockerHost&gt;http://host:2375&lt;/dockerHost&gt; &lt;images&gt; &lt;image&gt; &lt;name&gt;${project.name}&lt;/name&gt; &lt;alias&gt;${project.name}&lt;/alias&gt; &lt;build&gt; &lt;dockerFileDir&gt;${project.basedir}/src/main/docke&lt;/dockerFileDir&gt; &lt;assembly&gt; &lt;descriptorRef&gt;artifact&lt;/descriptorRef&gt; &lt;/assembly&gt; &lt;tags&gt; &lt;tag&gt;latest&lt;/tag&gt; &lt;/tags&gt; &lt;/build&gt; &lt;run&gt; &lt;!--数据卷，挂在文件的地址，例如输出项目日志--&gt; &lt;volumes&gt; &lt;bind&gt; &lt;volume&gt;/var/www/html:/upload&lt;/volume&gt; &lt;/bind&gt; &lt;/volumes&gt; &lt;namingStrategy&gt;alias&lt;/namingStrategy&gt; &lt;!--端口映射--&gt; &lt;ports&gt; &lt;port&gt;0.0.0.0:8086:8086&lt;/port&gt; &lt;/ports&gt; &lt;restartPolicy&gt; &lt;name&gt;always&lt;/name&gt; &lt;/restartPolicy&gt; &lt;/run&gt; &lt;/image&gt; &lt;/images&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 编写Dockerfile文件Dockerfile文件位置 src main docker Dockerfile 12345678FROM java:8VOLUME /tmpADD maven/upload-0.0.1-SNAPSHOT.jar app.jarRUN sh -c 'touch /app.jar'ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezoneENV JAVA_OPTS=&quot;&quot;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ] 推送1mvn clean package docker:stop docker:remove docker:build -DskipTests docker:run","link":"/2020/09/14/Spring%20Boot/SpringBoot%E4%B8%AD%E4%B8%8A%E4%BC%A0%E9%95%9C%E5%83%8F%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"},{"title":"curl使用","text":"上传图片1curl -F &quot;blob=@qr.png;type=image/png&quot; &quot;http://192.168.80.194:4869&quot;","link":"/2020/09/15/Tools/curl%E4%BD%BF%E7%94%A8/"},{"title":"npm使用","text":"使用淘宝镜像1--registry=https://registry.npm.taobao.org","link":"/2020/09/15/Tools/npm%E4%BD%BF%E7%94%A8/"},{"title":"生成证书","text":"参考 centos7 docker配置TLS认证的远程端口的证书生成教程（shell脚本一键生成） 一键生成脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#创建 Docker TLS 证书#!/bin/bash#相关配置信息SERVER=&quot;192.168.33.76&quot;PASSWORD=&quot;pass123456&quot;COUNTRY=&quot;CN&quot;STATE=&quot;广州省&quot;CITY=&quot;广州市&quot;ORGANIZATION=&quot;公司名称&quot;ORGANIZATIONAL_UNIT=&quot;Dev&quot;EMAIL=&quot;492376344@qq.com&quot;###开始生成文件###echo &quot;开始生成文件&quot;#切换到生产密钥的目录cd /etc/docker #生成ca私钥(使用aes256加密)openssl genrsa -aes256 -passout pass:$PASSWORD -out ca-key.pem 2048#生成ca证书，填写配置信息openssl req -new -x509 -passin &quot;pass:$PASSWORD&quot; -days 3650 -key ca-key.pem -sha256 -out ca.pem -subj &quot;/C=$COUNTRY/ST=$STATE/L=$CITY/O=$ORGANIZATION/OU=$ORGANIZATIONAL_UNIT/CN=$SERVER/emailAddress=$EMAIL&quot;#生成server证书私钥文件openssl genrsa -out server-key.pem 2048#生成server证书请求文件openssl req -subj &quot;/CN=$SERVER&quot; -new -key server-key.pem -out server.csr#使用CA证书及CA密钥以及上面的server证书请求文件进行签发，生成server自签证书openssl x509 -req -days 3650 -in server.csr -CA ca.pem -CAkey ca-key.pem -passin &quot;pass:$PASSWORD&quot; -CAcreateserial -out server-cert.pem#生成client证书RSA私钥文件openssl genrsa -out key.pem 2048#生成client证书请求文件openssl req -subj '/CN=client' -new -key key.pem -out client.csrsh -c 'echo &quot;extendedKeyUsage=clientAuth&quot; &gt; extfile.cnf'#生成client自签证书（根据上面的client私钥文件、client证书请求文件生成）openssl x509 -req -days 3650 -in client.csr -CA ca.pem -CAkey ca-key.pem -passin &quot;pass:$PASSWORD&quot; -CAcreateserial -out cert.pem -extfile extfile.cnf#更改密钥权限chmod 0400 ca-key.pem key.pem server-key.pem#更改密钥权限chmod 0444 ca.pem server-cert.pem cert.pem#删除无用文件rm client.csr server.csrecho &quot;生成文件完成&quot;###生成结束###","link":"/2020/09/14/Tools/%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6/"},{"title":"Swagger","text":"引入Maven坐标12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 编写配置文件1234567891011121314151617181920212223242526272829303132package cn.yearcon.joowing.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(&quot;cn.yearcon.joowing.controller&quot;)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;joowing数据对接接口&quot;) .version(&quot;1.0&quot;) .build(); }} 使用注解1234567891011121314151617181920212223package cn.yearcon.joowing.controller;import cn.yearcon.joowing.service.UserService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestController@Api(description = &quot;数据对接&quot;)public class TestController { @Autowired private UserService userService; @GetMapping(value = &quot;/hello&quot;) @ApiOperation(value = &quot;EZR会员积分同步(1188)&quot;, notes = &quot;EZR会员积分同步&quot;) public String sayHello() { System.out.println(userService.queryById(1).toString()); return &quot;Hello&quot;; }}","link":"/2020/09/12/Tools/Swagger/"},{"title":"Dockerfile","text":"参考 Docker与Dockerfile极简入门文档参考 你必须知道的Dockerfile 新建Dockerfile文件123456789101112131415161718192021222324252627#FROM 指定基础镜像，必须为第一个命令FROM java:8#LABEL 用于为镜像添加元数据LABEL maintainer=&quot;agrizzly.xyz&quot; version=&quot;1.0&quot; description=&quot;文件上传服务器&quot; by=&quot;grizzly&quot;#VOLUME 用于指定持久化目录VOLUME /tmp#WORKDIR 工作目录，类似于cd命令WORKDIR /opt#ADD 将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wgetADD upload-0.0.1-SNAPSHOT.jar app.jar#COPY 功能类似ADD，但是是不会自动解压文件，也不能访问网络资源#ENV 设置环境变量ENV TZ=Asia/Shanghai JAVA_OPTS=&quot;&quot;#RUN 构建镜像时执行的命令RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone#EXPOSE 映射端口EXPOSE 8086 8088#ENTRYPOINT 配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /opt/app.jar&quot; ] 执行1docker build -t upload:v1.0 . 创建容器1docker run -p 8086:8086 -v /tmp:/root -d upload:v1.0","link":"/2020/09/15/Docker/Dockerfile/"},{"title":"Java中的反射机制","text":"参考 用最直接的大白话来聊一聊Java中的反射机制 获得字节码文件的三种方式123456789// 1.通过全类名获取Class clazz = Class.forName(&quot;com.grizzly.base.User&quot;);// 2.通过对象获取User user = new User();Class clazz = user.getClass();// 3.通过类名获取Class clazz = User.class; 反射构造函数123456789101112131415161718// 1.反射一个参数构造函数Constructor c1= clazz.getConstructor(int.class);c1.newInstance(1)// 2.反射多个参数构造函数Constructor c2= clazz.getConstructor(int.class,String.class,String.class);c2.newInstance(1,&quot;www&quot;,&quot;123456&quot;);// 3.反射私有构造函数Constructor c3 = clazz.getDeclaredConstructor(int.class,String.class);c3.setAccessible(true); // 暴力反射c3.newInstance(2,&quot;wxf&quot;);// 4.反射所有构造函数Constructor [] c4 = clazz.getConstructors();for (Constructor c : c4){ System.out.println(c);} 反射类中的方法1234567891011121314151617181920212223242526272829303132Class clazz = user.class;User u = (User)clazz.newInstance();// 1.反射无参无返回公有方法Method m1 = clazz.getMethod(&quot;m1&quot;,null);m1.invoke(u,null)// 2.反射一个参数无返回公有方法Method m2 = clazz.getMethod(&quot;m2&quot;, String.class);m2.invoke(u,&quot;www&quot;)// 3.反射两个参数有返回公有方法Method m3 = clazz.getMethod(&quot;m3&quot;, String.class, int.class);m3.invoke(u,&quot;www&quot;,1234)// 4.反射一个参数无返回私有方法Method m4 = clazz.getDeclaredMethod(&quot;m4&quot;, Date.class);m4.setAccessible(true);m4.invoke(u,new Date())// 5.反射无参无返回静态方法Method m5 = clazz.getMethod(&quot;m5&quot;);m5.invoke(null)// 6.反射一个参数无返回私有静态方法Method m6 = clazz.getDeclaredMethod(&quot;m6&quot;, String[].class);m6.setAccessible(true);m6.invoke(null,(Object) new String[]{&quot;a&quot;,&quot;b&quot;})// 7.反射mian方法Method m7 = clazz.getMethod(&quot;main&quot;, String[].class);m7.invoke(null,(Object) new String[]{&quot;a&quot;,&quot;b&quot;}); 反射类中的属性字段123456789101112131415161718Class clazz = Person.class;Person p = (Person) clazz.newInstance();// 1.反射类中的公有属性Field f1 = clazz.getField(&quot;name&quot;);String name = (String) f1.get(p);System.out.println(name);// 2.反射类中的私有属性Field f2 = clazz.getDeclaredField(&quot;age&quot;);f2.setAccessible(true);int age = (int) f2.get(p);System.out.println(age);// 3.反射类中的公有静态属性Field f3 = clazz.getField(&quot;time&quot;);f3.set(null,new Date());System.out.println(Person.time);","link":"/2020/09/16/Java/Java%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"Java中的注解及自定义注解","text":"参考 Java中的注解以及自定义注解 元注解JDK中定义了四种元注解： @Retention：注解的保留范围，是个枚举，有如下可选值 RetentionPolicy.SOURCE:注解存在于源文件中 RetentionPolicy.CLASS:注解存在于源字节码文件中 RetentionPolicy.RUNTIME:注解存在于运行时 @Target：注解出现的位置(比如字段上、方法上等)，也是个枚举，有如下可选值 ElementType.TYPE ElementType.FIELD：字段 ElementType.METHOD：方法 ElementType.PARAMETER ElementType.CONSTRUCTOR ElementType.LOCAL_VARIABLE ElementType.ANNOTATION_TYPE ElementType.PACKAGE ElementType.TYPE_PARAMETER ElementType.TYPE_USE @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档 @Inherited: 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解 自定义 Annotation定义注解本身123public @interface MyAnnotation{ } 定义注解中的属性注解的属性的类型只能是：基本类型、String、Class、枚举、注解类型及以上类型的一维数组 定义注解12345678@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MyAnnotation { String value() default &quot;abc&quot;; String name() default &quot;zhangsan&quot;;} 使用注解利用反射获取方法上的注解，并获取对应的值12345678910111213141516171819202122public class Test { public static void main(String[] args) throws Exception { Class clazz = Class.forName(&quot;com.fours.intercepter.Test&quot;); Method[] ms = clazz.getMethods(); for (Method m : ms) { if(m.isAnnotationPresent(MyAnnotation.class)){ String value = m.getAnnotation(MyAnnotation.class).value(); String name = m.getAnnotation(MyAnnotation.class).name(); System.out.println(&quot;value:&quot;+value); System.out.println(&quot;name:&quot;+name); } } } @MyAnnotation(value = &quot;123&quot;,name = &quot;lisi&quot;) public static void test(){ System.out.println(&quot;这是test&quot;); }} 注解中的特殊属性(1)、特殊属性value：如果注解中只有一个属性，而且这个属性的名称是value的话，那么使用注解时可以省略value=部分，可以直接写成这样@MyAnnotation(“xxx”)； (2)、特殊类型[] value()：如果注解中只有一个属性，而且这个属性名称是value且数据类型是数组，那么使用方式：四种都ok，根据情况而定@MyAnnotationDemo1(value={“a”,”b”})@MyAnnotationDemo1({“a”,”b”})@MyAnnotationDemo1({“a”})@MyAnnotationDemo1(“a”) 写一个自定义注解的真实案例12345package com.cj.study.annotation.app1; public @interface MyTest { } 1234567891011public class DemoTest1 { @MyTest public void test1(){ System.out.println(&quot;test1执行了&quot;); } public void test2(){ System.out.println(&quot;test2执行了&quot;); }} 12345678910111213141516171819202122232425262728import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method; //反射注解：//取得类的字节码//反射其中的成员，此处就是方法成员//看谁的上面有MyTest注解//谁有，就执行谁public class MyJunitRunner { public static void main(String[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException { //取得类的字节码 Class clazz = DemoTest1.class; //反射其中的成员，此处就是方法成员 Method methods[] = clazz.getMethods();//得到DemoTest1中的所有公有的方法 //看谁的上面有MyTest注解 for(Method m:methods){ //谁有，就执行谁 boolean b = m.isAnnotationPresent(MyTest.class); System.out.println(b+&quot;===&quot;+m.getName()); if(b){ m.invoke(clazz.newInstance(), null); } } } }","link":"/2020/09/16/Java/Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"时间格式化","slug":"时间格式化","link":"/tags/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Cache","slug":"Cache","link":"/tags/Cache/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"DATE_FORMAT","slug":"DATE-FORMAT","link":"/tags/DATE-FORMAT/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","link":"/tags/MyBatis-Plus/"},{"name":"数据源","slug":"数据源","link":"/tags/%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"父工程","slug":"父工程","link":"/tags/%E7%88%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Swagger","slug":"Swagger","link":"/tags/Swagger/"},{"name":"Spring AOP","slug":"Spring-AOP","link":"/tags/Spring-AOP/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"DockerUI","slug":"DockerUI","link":"/tags/DockerUI/"},{"name":"安装","slug":"安装","link":"/tags/%E5%AE%89%E8%A3%85/"},{"name":"fabric8","slug":"fabric8","link":"/tags/fabric8/"},{"name":"Dcoker","slug":"Dcoker","link":"/tags/Dcoker/"},{"name":"远程访问","slug":"远程访问","link":"/tags/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"},{"name":"Spting Boot","slug":"Spting-Boot","link":"/tags/Spting-Boot/"},{"name":"Dockerfile","slug":"Dockerfile","link":"/tags/Dockerfile/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Redis学习笔记","slug":"Redis学习笔记","link":"/categories/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"MyBatis-Plus学习笔记","slug":"MyBatis-Plus学习笔记","link":"/categories/MyBatis-Plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Maven","slug":"Maven","link":"/categories/Maven/"},{"name":"Swagger","slug":"Swagger","link":"/categories/Swagger/"},{"name":"Spring AOP","slug":"Spring-AOP","link":"/categories/Spring-AOP/"},{"name":"CentOS","slug":"CentOS","link":"/categories/CentOS/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"Spting Boot","slug":"Spting-Boot","link":"/categories/Spting-Boot/"},{"name":"Dcoker","slug":"Spting-Boot/Dcoker","link":"/categories/Spting-Boot/Dcoker/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"注解","slug":"Java/注解","link":"/categories/Java/%E6%B3%A8%E8%A7%A3/"},{"name":"反射","slug":"Java/反射","link":"/categories/Java/%E5%8F%8D%E5%B0%84/"}]}